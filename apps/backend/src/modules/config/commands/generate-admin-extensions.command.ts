import { Command } from 'nestjs-command';
import fs from 'node:fs';
import path from 'node:path';

import { Injectable, Logger } from '@nestjs/common';
import { ConfigService as NestConfigService } from '@nestjs/config/dist/config.service';

import { getDiscoveredExtensions } from '../../../common/extensions/extensions.discovery-cache';
import { getEnvValue } from '../../../common/utils/config.utils';

type BundledEntry = {
	name: string;
	version?: string;
	kind: 'module' | 'plugin';
	display_name?: string;
	description?: string;
};

@Injectable()
export class GenerateAdminExtensionsCommand {
	private readonly logger = new Logger(GenerateAdminExtensionsCommand.name);

	private readonly filename = 'extensions.ts';

	constructor(private readonly configService: NestConfigService) {}

	@Command({
		command: 'config:generate-admin-extensions',
		describe: 'Generate Admin extensions import map (apps/admin/var/config/extensions.ts)',
	})
	async run(): Promise<void> {
		const outDir = this.configPath;
		fs.mkdirSync(outDir, { recursive: true });

		try {
			const { admin } = await getDiscoveredExtensions();

			const allow = this.loadAllowlist();

			// filter trusted only
			const trusted = admin.filter((a) => allow.has(a.pkgName));

			// --- Build file contents ---
			const header = `// AUTO-GENERATED. Do not edit by hand.
// Generated by backend command: config:generate-admin-extensions
import type { App } from 'vue';

`;

			// Named vs default imports (based on extensionExport)
			const imports = trusted
				.map((e, i) => {
					const entry = e.extensionEntry ?? 'dist/index.js';
					const importPath = path.relative(outDir, path.join(e.packageDir, entry)).replace(/\\/g, '/');

					return e.extensionExport
						? `import { ${e.extensionExport} as Ext${i} } from '${importPath.startsWith('.') ? importPath : './' + importPath}';`
						: `import Ext${i} from '${importPath.startsWith('.') ? importPath : './' + importPath}';`;
				})
				.join('\n');

			// Items for the exported array
			const items = trusted
				.map(
					(e, i) =>
						`  { name: '${e.pkgName}', module: Ext${i} as unknown as { install(app: App, options?: unknown): void }, kind: '${e.kind}' as const },`,
				)
				.join('\n');

			const body = `
export interface AdminExtension<TOptions = unknown> {
  name: string;
  module: { install(app: App, options?: TOptions): void } | ((app: App, options?: TOptions) => void);
  kind: 'module' | 'plugin';
}

export const extensions: AdminExtension[] = [
${items}
];
`;

			const extensionsTsPath = path.join(outDir, 'extensions.ts');
			fs.writeFileSync(extensionsTsPath, header + imports + body, 'utf8');

			// ----- generate bundled manifest JSON -----
			const manifest: { bundled: BundledEntry[] } = {
				bundled: trusted.map((e) => {
					// try read version (optional)
					let version: string | undefined;

					const pkgJson = path.resolve(e.packageDir ?? '', 'package.json');

					if (fs.existsSync(pkgJson)) {
						try {
							version = (JSON.parse(fs.readFileSync(pkgJson, 'utf8')) as { version?: string }).version;
						} catch {
							/* ignore */
						}
					}

					return {
						name: e.pkgName,
						version,
						kind: e.kind,
						display_name: e.displayName,
						description: e.description,
					};
				}),
			};

			const manifestPath = path.join(outDir, 'extensions.manifest.json');
			fs.writeFileSync(manifestPath, JSON.stringify(manifest, null, 2), 'utf8');

			this.logger.log(`Generated:
- ${extensionsTsPath}
- ${manifestPath}
(Trusted packages: ${trusted.length} / discovered admin: ${admin.length})`);
		} catch (err) {
			this.logger.error('Failed to generate Admin extensions import map', err as Error);

			throw err;
		}
	}

	private loadAllowlist(): Set<string> {
		const list = new Set<string>();

		const env = getEnvValue<string>(this.configService, 'FB_ADMIN_STATIC_EXTS', '')
			.split(',')
			.map((s) => s.trim())
			.filter(Boolean);

		env.forEach((n) => list.add(n));

		const allowPath = path.resolve(this.configPath, 'static-allowlist.json');

		if (fs.existsSync(allowPath)) {
			try {
				const json = JSON.parse(fs.readFileSync(allowPath, 'utf8')) as { packages?: string[] };
				(json.packages ?? []).forEach((n) => list.add(n));
			} catch {
				/* ignore malformed */
			}
		}

		return list;
	}

	private get configPath(): string {
		return getEnvValue<string>(
			this.configService,
			'FB_CONFIG_PATH',
			path.resolve(__dirname, '../../../../../../var/data'),
		);
	}
}
